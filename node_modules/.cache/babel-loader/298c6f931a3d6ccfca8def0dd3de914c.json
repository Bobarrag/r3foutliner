{"ast":null,"code":"import { AdditiveBlending, Color, DoubleSide, Matrix4, MeshDepthMaterial, NoBlending, RGBADepthPacking, ShaderMaterial, UniformsUtils, Vector2, Vector3, WebGLRenderTarget } from 'three';\nimport { Pass, FullScreenQuad } from './Pass.js';\nimport { CopyShader } from '../shaders/CopyShader.js';\n\nclass OutlinePass extends Pass {\n  constructor(resolution, scene, camera, selectedObjects) {\n    super();\n    this.renderScene = scene;\n    this.renderCamera = camera;\n    this.selectedObjects = selectedObjects !== undefined ? selectedObjects : [];\n    this.visibleEdgeColor = new Color(1, 1, 1);\n    this.hiddenEdgeColor = new Color(0.1, 0.04, 0.02);\n    this.edgeGlow = 0.0;\n    this.usePatternTexture = false;\n    this.edgeThickness = 1.0;\n    this.edgeStrength = 3.0;\n    this.downSampleRatio = 2;\n    this.pulsePeriod = 0;\n    this._visibilityCache = new Map();\n    this.resolution = resolution !== undefined ? new Vector2(resolution.x, resolution.y) : new Vector2(256, 256);\n    const resx = Math.round(this.resolution.x / this.downSampleRatio);\n    const resy = Math.round(this.resolution.y / this.downSampleRatio);\n    this.renderTargetMaskBuffer = new WebGLRenderTarget(this.resolution.x, this.resolution.y);\n    this.renderTargetMaskBuffer.texture.name = 'OutlinePass.mask';\n    this.renderTargetMaskBuffer.texture.generateMipmaps = false;\n    this.depthMaterial = new MeshDepthMaterial();\n    this.depthMaterial.side = DoubleSide;\n    this.depthMaterial.depthPacking = RGBADepthPacking;\n    this.depthMaterial.blending = NoBlending;\n    this.prepareMaskMaterial = this.getPrepareMaskMaterial();\n    this.prepareMaskMaterial.side = DoubleSide;\n    this.prepareMaskMaterial.fragmentShader = replaceDepthToViewZ(this.prepareMaskMaterial.fragmentShader, this.renderCamera);\n    this.renderTargetDepthBuffer = new WebGLRenderTarget(this.resolution.x, this.resolution.y);\n    this.renderTargetDepthBuffer.texture.name = 'OutlinePass.depth';\n    this.renderTargetDepthBuffer.texture.generateMipmaps = false;\n    this.renderTargetMaskDownSampleBuffer = new WebGLRenderTarget(resx, resy);\n    this.renderTargetMaskDownSampleBuffer.texture.name = 'OutlinePass.depthDownSample';\n    this.renderTargetMaskDownSampleBuffer.texture.generateMipmaps = false;\n    this.renderTargetBlurBuffer1 = new WebGLRenderTarget(resx, resy);\n    this.renderTargetBlurBuffer1.texture.name = 'OutlinePass.blur1';\n    this.renderTargetBlurBuffer1.texture.generateMipmaps = false;\n    this.renderTargetBlurBuffer2 = new WebGLRenderTarget(Math.round(resx / 2), Math.round(resy / 2));\n    this.renderTargetBlurBuffer2.texture.name = 'OutlinePass.blur2';\n    this.renderTargetBlurBuffer2.texture.generateMipmaps = false;\n    this.edgeDetectionMaterial = this.getEdgeDetectionMaterial();\n    this.renderTargetEdgeBuffer1 = new WebGLRenderTarget(resx, resy);\n    this.renderTargetEdgeBuffer1.texture.name = 'OutlinePass.edge1';\n    this.renderTargetEdgeBuffer1.texture.generateMipmaps = false;\n    this.renderTargetEdgeBuffer2 = new WebGLRenderTarget(Math.round(resx / 2), Math.round(resy / 2));\n    this.renderTargetEdgeBuffer2.texture.name = 'OutlinePass.edge2';\n    this.renderTargetEdgeBuffer2.texture.generateMipmaps = false;\n    const MAX_EDGE_THICKNESS = 4;\n    const MAX_EDGE_GLOW = 4;\n    this.separableBlurMaterial1 = this.getSeperableBlurMaterial(MAX_EDGE_THICKNESS);\n    this.separableBlurMaterial1.uniforms['texSize'].value.set(resx, resy);\n    this.separableBlurMaterial1.uniforms['kernelRadius'].value = 1;\n    this.separableBlurMaterial2 = this.getSeperableBlurMaterial(MAX_EDGE_GLOW);\n    this.separableBlurMaterial2.uniforms['texSize'].value.set(Math.round(resx / 2), Math.round(resy / 2));\n    this.separableBlurMaterial2.uniforms['kernelRadius'].value = MAX_EDGE_GLOW; // Overlay material\n\n    this.overlayMaterial = this.getOverlayMaterial(); // copy material\n\n    if (CopyShader === undefined) console.error('THREE.OutlinePass relies on CopyShader');\n    const copyShader = CopyShader;\n    this.copyUniforms = UniformsUtils.clone(copyShader.uniforms);\n    this.copyUniforms['opacity'].value = 1.0;\n    this.materialCopy = new ShaderMaterial({\n      uniforms: this.copyUniforms,\n      vertexShader: copyShader.vertexShader,\n      fragmentShader: copyShader.fragmentShader,\n      blending: NoBlending,\n      depthTest: false,\n      depthWrite: false,\n      transparent: true\n    });\n    this.enabled = true;\n    this.needsSwap = false;\n    this._oldClearColor = new Color();\n    this.oldClearAlpha = 1;\n    this.fsQuad = new FullScreenQuad(null);\n    this.tempPulseColor1 = new Color();\n    this.tempPulseColor2 = new Color();\n    this.textureMatrix = new Matrix4();\n\n    function replaceDepthToViewZ(string, camera) {\n      const type = camera.isPerspectiveCamera ? 'perspective' : 'orthographic';\n      return string.replace(/DEPTH_TO_VIEW_Z/g, type + 'DepthToViewZ');\n    }\n  }\n\n  dispose() {\n    this.renderTargetMaskBuffer.dispose();\n    this.renderTargetDepthBuffer.dispose();\n    this.renderTargetMaskDownSampleBuffer.dispose();\n    this.renderTargetBlurBuffer1.dispose();\n    this.renderTargetBlurBuffer2.dispose();\n    this.renderTargetEdgeBuffer1.dispose();\n    this.renderTargetEdgeBuffer2.dispose();\n  }\n\n  setSize(width, height) {\n    this.renderTargetMaskBuffer.setSize(width, height);\n    this.renderTargetDepthBuffer.setSize(width, height);\n    let resx = Math.round(width / this.downSampleRatio);\n    let resy = Math.round(height / this.downSampleRatio);\n    this.renderTargetMaskDownSampleBuffer.setSize(resx, resy);\n    this.renderTargetBlurBuffer1.setSize(resx, resy);\n    this.renderTargetEdgeBuffer1.setSize(resx, resy);\n    this.separableBlurMaterial1.uniforms['texSize'].value.set(resx, resy);\n    resx = Math.round(resx / 2);\n    resy = Math.round(resy / 2);\n    this.renderTargetBlurBuffer2.setSize(resx, resy);\n    this.renderTargetEdgeBuffer2.setSize(resx, resy);\n    this.separableBlurMaterial2.uniforms['texSize'].value.set(resx, resy);\n  }\n\n  changeVisibilityOfSelectedObjects(bVisible) {\n    const cache = this._visibilityCache;\n\n    function gatherSelectedMeshesCallBack(object) {\n      if (object.isMesh) {\n        if (bVisible === true) {\n          object.visible = cache.get(object);\n        } else {\n          cache.set(object, object.visible);\n          object.visible = bVisible;\n        }\n      }\n    }\n\n    for (let i = 0; i < this.selectedObjects.length; i++) {\n      const selectedObject = this.selectedObjects[i];\n      selectedObject.traverse(gatherSelectedMeshesCallBack);\n    }\n  }\n\n  changeVisibilityOfNonSelectedObjects(bVisible) {\n    const cache = this._visibilityCache;\n    const selectedMeshes = [];\n\n    function gatherSelectedMeshesCallBack(object) {\n      if (object.isMesh) selectedMeshes.push(object);\n    }\n\n    for (let i = 0; i < this.selectedObjects.length; i++) {\n      const selectedObject = this.selectedObjects[i];\n      selectedObject.traverse(gatherSelectedMeshesCallBack);\n    }\n\n    function VisibilityChangeCallBack(object) {\n      if (object.isMesh || object.isSprite) {\n        // only meshes and sprites are supported by OutlinePass\n        let bFound = false;\n\n        for (let i = 0; i < selectedMeshes.length; i++) {\n          const selectedObjectId = selectedMeshes[i].id;\n\n          if (selectedObjectId === object.id) {\n            bFound = true;\n            break;\n          }\n        }\n\n        if (bFound === false) {\n          const visibility = object.visible;\n\n          if (bVisible === false || cache.get(object) === true) {\n            object.visible = bVisible;\n          }\n\n          cache.set(object, visibility);\n        }\n      } else if (object.isPoints || object.isLine) {\n        // the visibilty of points and lines is always set to false in order to\n        // not affect the outline computation\n        if (bVisible === true) {\n          object.visible = cache.get(object); // restore\n        } else {\n          cache.set(object, object.visible);\n          object.visible = bVisible;\n        }\n      }\n    }\n\n    this.renderScene.traverse(VisibilityChangeCallBack);\n  }\n\n  updateTextureMatrix() {\n    this.textureMatrix.set(0.5, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0);\n    this.textureMatrix.multiply(this.renderCamera.projectionMatrix);\n    this.textureMatrix.multiply(this.renderCamera.matrixWorldInverse);\n  }\n\n  render(renderer, writeBuffer, readBuffer, deltaTime, maskActive) {\n    if (this.selectedObjects.length > 0) {\n      renderer.getClearColor(this._oldClearColor);\n      this.oldClearAlpha = renderer.getClearAlpha();\n      const oldAutoClear = renderer.autoClear;\n      renderer.autoClear = false;\n      if (maskActive) renderer.state.buffers.stencil.setTest(false);\n      renderer.setClearColor(0xffffff, 1); // Make selected objects invisible\n\n      this.changeVisibilityOfSelectedObjects(false);\n      const currentBackground = this.renderScene.background;\n      this.renderScene.background = null; // 1. Draw Non Selected objects in the depth buffer\n\n      this.renderScene.overrideMaterial = this.depthMaterial;\n      renderer.setRenderTarget(this.renderTargetDepthBuffer);\n      renderer.clear();\n      renderer.render(this.renderScene, this.renderCamera); // Make selected objects visible\n\n      this.changeVisibilityOfSelectedObjects(true);\n\n      this._visibilityCache.clear(); // Update Texture Matrix for Depth compare\n\n\n      this.updateTextureMatrix(); // Make non selected objects invisible, and draw only the selected objects, by comparing the depth buffer of non selected objects\n\n      this.changeVisibilityOfNonSelectedObjects(false);\n      this.renderScene.overrideMaterial = this.prepareMaskMaterial;\n      this.prepareMaskMaterial.uniforms['cameraNearFar'].value.set(this.renderCamera.near, this.renderCamera.far);\n      this.prepareMaskMaterial.uniforms['depthTexture'].value = this.renderTargetDepthBuffer.texture;\n      this.prepareMaskMaterial.uniforms['textureMatrix'].value = this.textureMatrix;\n      renderer.setRenderTarget(this.renderTargetMaskBuffer);\n      renderer.clear();\n      renderer.render(this.renderScene, this.renderCamera);\n      this.renderScene.overrideMaterial = null;\n      this.changeVisibilityOfNonSelectedObjects(true);\n\n      this._visibilityCache.clear();\n\n      this.renderScene.background = currentBackground; // 2. Downsample to Half resolution\n\n      this.fsQuad.material = this.materialCopy;\n      this.copyUniforms['tDiffuse'].value = this.renderTargetMaskBuffer.texture;\n      renderer.setRenderTarget(this.renderTargetMaskDownSampleBuffer);\n      renderer.clear();\n      this.fsQuad.render(renderer);\n      this.tempPulseColor1.copy(this.visibleEdgeColor);\n      this.tempPulseColor2.copy(this.hiddenEdgeColor);\n\n      if (this.pulsePeriod > 0) {\n        const scalar = (1 + 0.25) / 2 + Math.cos(performance.now() * 0.01 / this.pulsePeriod) * (1.0 - 0.25) / 2;\n        this.tempPulseColor1.multiplyScalar(scalar);\n        this.tempPulseColor2.multiplyScalar(scalar);\n      } // 3. Apply Edge Detection Pass\n\n\n      this.fsQuad.material = this.edgeDetectionMaterial;\n      this.edgeDetectionMaterial.uniforms['maskTexture'].value = this.renderTargetMaskDownSampleBuffer.texture;\n      this.edgeDetectionMaterial.uniforms['texSize'].value.set(this.renderTargetMaskDownSampleBuffer.width, this.renderTargetMaskDownSampleBuffer.height);\n      this.edgeDetectionMaterial.uniforms['visibleEdgeColor'].value = this.tempPulseColor1;\n      this.edgeDetectionMaterial.uniforms['hiddenEdgeColor'].value = this.tempPulseColor2;\n      renderer.setRenderTarget(this.renderTargetEdgeBuffer1);\n      renderer.clear();\n      this.fsQuad.render(renderer); // 4. Apply Blur on Half res\n\n      this.fsQuad.material = this.separableBlurMaterial1;\n      this.separableBlurMaterial1.uniforms['colorTexture'].value = this.renderTargetEdgeBuffer1.texture;\n      this.separableBlurMaterial1.uniforms['direction'].value = OutlinePass.BlurDirectionX;\n      this.separableBlurMaterial1.uniforms['kernelRadius'].value = this.edgeThickness;\n      renderer.setRenderTarget(this.renderTargetBlurBuffer1);\n      renderer.clear();\n      this.fsQuad.render(renderer);\n      this.separableBlurMaterial1.uniforms['colorTexture'].value = this.renderTargetBlurBuffer1.texture;\n      this.separableBlurMaterial1.uniforms['direction'].value = OutlinePass.BlurDirectionY;\n      renderer.setRenderTarget(this.renderTargetEdgeBuffer1);\n      renderer.clear();\n      this.fsQuad.render(renderer); // Apply Blur on quarter res\n\n      this.fsQuad.material = this.separableBlurMaterial2;\n      this.separableBlurMaterial2.uniforms['colorTexture'].value = this.renderTargetEdgeBuffer1.texture;\n      this.separableBlurMaterial2.uniforms['direction'].value = OutlinePass.BlurDirectionX;\n      renderer.setRenderTarget(this.renderTargetBlurBuffer2);\n      renderer.clear();\n      this.fsQuad.render(renderer);\n      this.separableBlurMaterial2.uniforms['colorTexture'].value = this.renderTargetBlurBuffer2.texture;\n      this.separableBlurMaterial2.uniforms['direction'].value = OutlinePass.BlurDirectionY;\n      renderer.setRenderTarget(this.renderTargetEdgeBuffer2);\n      renderer.clear();\n      this.fsQuad.render(renderer); // Blend it additively over the input texture\n\n      this.fsQuad.material = this.overlayMaterial;\n      this.overlayMaterial.uniforms['maskTexture'].value = this.renderTargetMaskBuffer.texture;\n      this.overlayMaterial.uniforms['edgeTexture1'].value = this.renderTargetEdgeBuffer1.texture;\n      this.overlayMaterial.uniforms['edgeTexture2'].value = this.renderTargetEdgeBuffer2.texture;\n      this.overlayMaterial.uniforms['patternTexture'].value = this.patternTexture;\n      this.overlayMaterial.uniforms['edgeStrength'].value = this.edgeStrength;\n      this.overlayMaterial.uniforms['edgeGlow'].value = this.edgeGlow;\n      this.overlayMaterial.uniforms['usePatternTexture'].value = this.usePatternTexture;\n      if (maskActive) renderer.state.buffers.stencil.setTest(true);\n      renderer.setRenderTarget(readBuffer);\n      this.fsQuad.render(renderer);\n      renderer.setClearColor(this._oldClearColor, this.oldClearAlpha);\n      renderer.autoClear = oldAutoClear;\n    }\n\n    if (this.renderToScreen) {\n      this.fsQuad.material = this.materialCopy;\n      this.copyUniforms['tDiffuse'].value = readBuffer.texture;\n      renderer.setRenderTarget(null);\n      this.fsQuad.render(renderer);\n    }\n  }\n\n  getPrepareMaskMaterial() {\n    return new ShaderMaterial({\n      uniforms: {\n        'depthTexture': {\n          value: null\n        },\n        'cameraNearFar': {\n          value: new Vector2(0.5, 0.5)\n        },\n        'textureMatrix': {\n          value: null\n        }\n      },\n      vertexShader: `#include <morphtarget_pars_vertex>\n\t\t\t\t#include <skinning_pars_vertex>\n\n\t\t\t\tvarying vec4 projTexCoord;\n\t\t\t\tvarying vec4 vPosition;\n\t\t\t\tuniform mat4 textureMatrix;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\t#include <skinbase_vertex>\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <morphtarget_vertex>\n\t\t\t\t\t#include <skinning_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t\tvPosition = mvPosition;\n\t\t\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\n\t\t\t\t\tprojTexCoord = textureMatrix * worldPosition;\n\n\t\t\t\t}`,\n      fragmentShader: `#include <packing>\n\t\t\t\tvarying vec4 vPosition;\n\t\t\t\tvarying vec4 projTexCoord;\n\t\t\t\tuniform sampler2D depthTexture;\n\t\t\t\tuniform vec2 cameraNearFar;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tfloat depth = unpackRGBAToDepth(texture2DProj( depthTexture, projTexCoord ));\n\t\t\t\t\tfloat viewZ = - DEPTH_TO_VIEW_Z( depth, cameraNearFar.x, cameraNearFar.y );\n\t\t\t\t\tfloat depthTest = (-vPosition.z > viewZ) ? 1.0 : 0.0;\n\t\t\t\t\tgl_FragColor = vec4(0.0, depthTest, 1.0, 1.0);\n\n\t\t\t\t}`\n    });\n  }\n\n  getEdgeDetectionMaterial() {\n    return new ShaderMaterial({\n      uniforms: {\n        'maskTexture': {\n          value: null\n        },\n        'texSize': {\n          value: new Vector2(0.5, 0.5)\n        },\n        'visibleEdgeColor': {\n          value: new Vector3(1.0, 1.0, 1.0)\n        },\n        'hiddenEdgeColor': {\n          value: new Vector3(1.0, 1.0, 1.0)\n        }\n      },\n      vertexShader: `varying vec2 vUv;\n\n\t\t\t\tvoid main() {\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t}`,\n      fragmentShader: `varying vec2 vUv;\n\n\t\t\t\tuniform sampler2D maskTexture;\n\t\t\t\tuniform vec2 texSize;\n\t\t\t\tuniform vec3 visibleEdgeColor;\n\t\t\t\tuniform vec3 hiddenEdgeColor;\n\n\t\t\t\tvoid main() {\n\t\t\t\t\tvec2 invSize = 1.0 / texSize;\n\t\t\t\t\tvec4 uvOffset = vec4(1.0, 0.0, 0.0, 1.0) * vec4(invSize, invSize);\n\t\t\t\t\tvec4 c1 = texture2D( maskTexture, vUv + uvOffset.xy);\n\t\t\t\t\tvec4 c2 = texture2D( maskTexture, vUv - uvOffset.xy);\n\t\t\t\t\tvec4 c3 = texture2D( maskTexture, vUv + uvOffset.yw);\n\t\t\t\t\tvec4 c4 = texture2D( maskTexture, vUv - uvOffset.yw);\n\t\t\t\t\tfloat diff1 = (c1.r - c2.r)*0.5;\n\t\t\t\t\tfloat diff2 = (c3.r - c4.r)*0.5;\n\t\t\t\t\tfloat d = length( vec2(diff1, diff2) );\n\t\t\t\t\tfloat a1 = min(c1.g, c2.g);\n\t\t\t\t\tfloat a2 = min(c3.g, c4.g);\n\t\t\t\t\tfloat visibilityFactor = min(a1, a2);\n\t\t\t\t\tvec3 edgeColor = 1.0 - visibilityFactor > 0.001 ? visibleEdgeColor : hiddenEdgeColor;\n\t\t\t\t\tgl_FragColor = vec4(edgeColor, 1.0) * vec4(d);\n\t\t\t\t}`\n    });\n  }\n\n  getSeperableBlurMaterial(maxRadius) {\n    return new ShaderMaterial({\n      defines: {\n        'MAX_RADIUS': maxRadius\n      },\n      uniforms: {\n        'colorTexture': {\n          value: null\n        },\n        'texSize': {\n          value: new Vector2(0.5, 0.5)\n        },\n        'direction': {\n          value: new Vector2(0.5, 0.5)\n        },\n        'kernelRadius': {\n          value: 1.0\n        }\n      },\n      vertexShader: `varying vec2 vUv;\n\n\t\t\t\tvoid main() {\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t}`,\n      fragmentShader: `#include <common>\n\t\t\t\tvarying vec2 vUv;\n\t\t\t\tuniform sampler2D colorTexture;\n\t\t\t\tuniform vec2 texSize;\n\t\t\t\tuniform vec2 direction;\n\t\t\t\tuniform float kernelRadius;\n\n\t\t\t\tfloat gaussianPdf(in float x, in float sigma) {\n\t\t\t\t\treturn 0.39894 * exp( -0.5 * x * x/( sigma * sigma))/sigma;\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\t\t\t\t\tvec2 invSize = 1.0 / texSize;\n\t\t\t\t\tfloat weightSum = gaussianPdf(0.0, kernelRadius);\n\t\t\t\t\tvec4 diffuseSum = texture2D( colorTexture, vUv) * weightSum;\n\t\t\t\t\tvec2 delta = direction * invSize * kernelRadius/float(MAX_RADIUS);\n\t\t\t\t\tvec2 uvOffset = delta;\n\t\t\t\t\tfor( int i = 1; i <= MAX_RADIUS; i ++ ) {\n\t\t\t\t\t\tfloat w = gaussianPdf(uvOffset.x, kernelRadius);\n\t\t\t\t\t\tvec4 sample1 = texture2D( colorTexture, vUv + uvOffset);\n\t\t\t\t\t\tvec4 sample2 = texture2D( colorTexture, vUv - uvOffset);\n\t\t\t\t\t\tdiffuseSum += ((sample1 + sample2) * w);\n\t\t\t\t\t\tweightSum += (2.0 * w);\n\t\t\t\t\t\tuvOffset += delta;\n\t\t\t\t\t}\n\t\t\t\t\tgl_FragColor = diffuseSum/weightSum;\n\t\t\t\t}`\n    });\n  }\n\n  getOverlayMaterial() {\n    return new ShaderMaterial({\n      uniforms: {\n        'maskTexture': {\n          value: null\n        },\n        'edgeTexture1': {\n          value: null\n        },\n        'edgeTexture2': {\n          value: null\n        },\n        'patternTexture': {\n          value: null\n        },\n        'edgeStrength': {\n          value: 1.0\n        },\n        'edgeGlow': {\n          value: 1.0\n        },\n        'usePatternTexture': {\n          value: 0.0\n        }\n      },\n      vertexShader: `varying vec2 vUv;\n\n\t\t\t\tvoid main() {\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t}`,\n      fragmentShader: `varying vec2 vUv;\n\n\t\t\t\tuniform sampler2D maskTexture;\n\t\t\t\tuniform sampler2D edgeTexture1;\n\t\t\t\tuniform sampler2D edgeTexture2;\n\t\t\t\tuniform sampler2D patternTexture;\n\t\t\t\tuniform float edgeStrength;\n\t\t\t\tuniform float edgeGlow;\n\t\t\t\tuniform bool usePatternTexture;\n\n\t\t\t\tvoid main() {\n\t\t\t\t\tvec4 edgeValue1 = texture2D(edgeTexture1, vUv);\n\t\t\t\t\tvec4 edgeValue2 = texture2D(edgeTexture2, vUv);\n\t\t\t\t\tvec4 maskColor = texture2D(maskTexture, vUv);\n\t\t\t\t\tvec4 patternColor = texture2D(patternTexture, 6.0 * vUv);\n\t\t\t\t\tfloat visibilityFactor = 1.0 - maskColor.g > 0.0 ? 1.0 : 0.5;\n\t\t\t\t\tvec4 edgeValue = edgeValue1 + edgeValue2 * edgeGlow;\n\t\t\t\t\tvec4 finalColor = edgeStrength * maskColor.r * edgeValue;\n\t\t\t\t\tif(usePatternTexture)\n\t\t\t\t\t\tfinalColor += + visibilityFactor * (1.0 - maskColor.r) * (1.0 - patternColor.r);\n\t\t\t\t\tgl_FragColor = finalColor;\n\t\t\t\t}`,\n      blending: AdditiveBlending,\n      depthTest: false,\n      depthWrite: false,\n      transparent: true\n    });\n  }\n\n}\n\nOutlinePass.BlurDirectionX = new Vector2(1.0, 0.0);\nOutlinePass.BlurDirectionY = new Vector2(0.0, 1.0);\nexport { OutlinePass };","map":{"version":3,"names":["AdditiveBlending","Color","DoubleSide","Matrix4","MeshDepthMaterial","NoBlending","RGBADepthPacking","ShaderMaterial","UniformsUtils","Vector2","Vector3","WebGLRenderTarget","Pass","FullScreenQuad","CopyShader","OutlinePass","constructor","resolution","scene","camera","selectedObjects","renderScene","renderCamera","undefined","visibleEdgeColor","hiddenEdgeColor","edgeGlow","usePatternTexture","edgeThickness","edgeStrength","downSampleRatio","pulsePeriod","_visibilityCache","Map","x","y","resx","Math","round","resy","renderTargetMaskBuffer","texture","name","generateMipmaps","depthMaterial","side","depthPacking","blending","prepareMaskMaterial","getPrepareMaskMaterial","fragmentShader","replaceDepthToViewZ","renderTargetDepthBuffer","renderTargetMaskDownSampleBuffer","renderTargetBlurBuffer1","renderTargetBlurBuffer2","edgeDetectionMaterial","getEdgeDetectionMaterial","renderTargetEdgeBuffer1","renderTargetEdgeBuffer2","MAX_EDGE_THICKNESS","MAX_EDGE_GLOW","separableBlurMaterial1","getSeperableBlurMaterial","uniforms","value","set","separableBlurMaterial2","overlayMaterial","getOverlayMaterial","console","error","copyShader","copyUniforms","clone","materialCopy","vertexShader","depthTest","depthWrite","transparent","enabled","needsSwap","_oldClearColor","oldClearAlpha","fsQuad","tempPulseColor1","tempPulseColor2","textureMatrix","string","type","isPerspectiveCamera","replace","dispose","setSize","width","height","changeVisibilityOfSelectedObjects","bVisible","cache","gatherSelectedMeshesCallBack","object","isMesh","visible","get","i","length","selectedObject","traverse","changeVisibilityOfNonSelectedObjects","selectedMeshes","push","VisibilityChangeCallBack","isSprite","bFound","selectedObjectId","id","visibility","isPoints","isLine","updateTextureMatrix","multiply","projectionMatrix","matrixWorldInverse","render","renderer","writeBuffer","readBuffer","deltaTime","maskActive","getClearColor","getClearAlpha","oldAutoClear","autoClear","state","buffers","stencil","setTest","setClearColor","currentBackground","background","overrideMaterial","setRenderTarget","clear","near","far","material","copy","scalar","cos","performance","now","multiplyScalar","BlurDirectionX","BlurDirectionY","patternTexture","renderToScreen","maxRadius","defines"],"sources":["/Users/bonnybarragan/Documents/astrologuide/node_modules/three/examples/jsm/postprocessing/OutlinePass.js"],"sourcesContent":["import {\n\tAdditiveBlending,\n\tColor,\n\tDoubleSide,\n\tMatrix4,\n\tMeshDepthMaterial,\n\tNoBlending,\n\tRGBADepthPacking,\n\tShaderMaterial,\n\tUniformsUtils,\n\tVector2,\n\tVector3,\n\tWebGLRenderTarget\n} from 'three';\nimport { Pass, FullScreenQuad } from './Pass.js';\nimport { CopyShader } from '../shaders/CopyShader.js';\n\nclass OutlinePass extends Pass {\n\n\tconstructor( resolution, scene, camera, selectedObjects ) {\n\n\t\tsuper();\n\n\t\tthis.renderScene = scene;\n\t\tthis.renderCamera = camera;\n\t\tthis.selectedObjects = selectedObjects !== undefined ? selectedObjects : [];\n\t\tthis.visibleEdgeColor = new Color( 1, 1, 1 );\n\t\tthis.hiddenEdgeColor = new Color( 0.1, 0.04, 0.02 );\n\t\tthis.edgeGlow = 0.0;\n\t\tthis.usePatternTexture = false;\n\t\tthis.edgeThickness = 1.0;\n\t\tthis.edgeStrength = 3.0;\n\t\tthis.downSampleRatio = 2;\n\t\tthis.pulsePeriod = 0;\n\n\t\tthis._visibilityCache = new Map();\n\n\n\t\tthis.resolution = ( resolution !== undefined ) ? new Vector2( resolution.x, resolution.y ) : new Vector2( 256, 256 );\n\n\t\tconst resx = Math.round( this.resolution.x / this.downSampleRatio );\n\t\tconst resy = Math.round( this.resolution.y / this.downSampleRatio );\n\n\t\tthis.renderTargetMaskBuffer = new WebGLRenderTarget( this.resolution.x, this.resolution.y );\n\t\tthis.renderTargetMaskBuffer.texture.name = 'OutlinePass.mask';\n\t\tthis.renderTargetMaskBuffer.texture.generateMipmaps = false;\n\n\t\tthis.depthMaterial = new MeshDepthMaterial();\n\t\tthis.depthMaterial.side = DoubleSide;\n\t\tthis.depthMaterial.depthPacking = RGBADepthPacking;\n\t\tthis.depthMaterial.blending = NoBlending;\n\n\t\tthis.prepareMaskMaterial = this.getPrepareMaskMaterial();\n\t\tthis.prepareMaskMaterial.side = DoubleSide;\n\t\tthis.prepareMaskMaterial.fragmentShader = replaceDepthToViewZ( this.prepareMaskMaterial.fragmentShader, this.renderCamera );\n\n\t\tthis.renderTargetDepthBuffer = new WebGLRenderTarget( this.resolution.x, this.resolution.y );\n\t\tthis.renderTargetDepthBuffer.texture.name = 'OutlinePass.depth';\n\t\tthis.renderTargetDepthBuffer.texture.generateMipmaps = false;\n\n\t\tthis.renderTargetMaskDownSampleBuffer = new WebGLRenderTarget( resx, resy );\n\t\tthis.renderTargetMaskDownSampleBuffer.texture.name = 'OutlinePass.depthDownSample';\n\t\tthis.renderTargetMaskDownSampleBuffer.texture.generateMipmaps = false;\n\n\t\tthis.renderTargetBlurBuffer1 = new WebGLRenderTarget( resx, resy );\n\t\tthis.renderTargetBlurBuffer1.texture.name = 'OutlinePass.blur1';\n\t\tthis.renderTargetBlurBuffer1.texture.generateMipmaps = false;\n\t\tthis.renderTargetBlurBuffer2 = new WebGLRenderTarget( Math.round( resx / 2 ), Math.round( resy / 2 ) );\n\t\tthis.renderTargetBlurBuffer2.texture.name = 'OutlinePass.blur2';\n\t\tthis.renderTargetBlurBuffer2.texture.generateMipmaps = false;\n\n\t\tthis.edgeDetectionMaterial = this.getEdgeDetectionMaterial();\n\t\tthis.renderTargetEdgeBuffer1 = new WebGLRenderTarget( resx, resy );\n\t\tthis.renderTargetEdgeBuffer1.texture.name = 'OutlinePass.edge1';\n\t\tthis.renderTargetEdgeBuffer1.texture.generateMipmaps = false;\n\t\tthis.renderTargetEdgeBuffer2 = new WebGLRenderTarget( Math.round( resx / 2 ), Math.round( resy / 2 ) );\n\t\tthis.renderTargetEdgeBuffer2.texture.name = 'OutlinePass.edge2';\n\t\tthis.renderTargetEdgeBuffer2.texture.generateMipmaps = false;\n\n\t\tconst MAX_EDGE_THICKNESS = 4;\n\t\tconst MAX_EDGE_GLOW = 4;\n\n\t\tthis.separableBlurMaterial1 = this.getSeperableBlurMaterial( MAX_EDGE_THICKNESS );\n\t\tthis.separableBlurMaterial1.uniforms[ 'texSize' ].value.set( resx, resy );\n\t\tthis.separableBlurMaterial1.uniforms[ 'kernelRadius' ].value = 1;\n\t\tthis.separableBlurMaterial2 = this.getSeperableBlurMaterial( MAX_EDGE_GLOW );\n\t\tthis.separableBlurMaterial2.uniforms[ 'texSize' ].value.set( Math.round( resx / 2 ), Math.round( resy / 2 ) );\n\t\tthis.separableBlurMaterial2.uniforms[ 'kernelRadius' ].value = MAX_EDGE_GLOW;\n\n\t\t// Overlay material\n\t\tthis.overlayMaterial = this.getOverlayMaterial();\n\n\t\t// copy material\n\t\tif ( CopyShader === undefined ) console.error( 'THREE.OutlinePass relies on CopyShader' );\n\n\t\tconst copyShader = CopyShader;\n\n\t\tthis.copyUniforms = UniformsUtils.clone( copyShader.uniforms );\n\t\tthis.copyUniforms[ 'opacity' ].value = 1.0;\n\n\t\tthis.materialCopy = new ShaderMaterial( {\n\t\t\tuniforms: this.copyUniforms,\n\t\t\tvertexShader: copyShader.vertexShader,\n\t\t\tfragmentShader: copyShader.fragmentShader,\n\t\t\tblending: NoBlending,\n\t\t\tdepthTest: false,\n\t\t\tdepthWrite: false,\n\t\t\ttransparent: true\n\t\t} );\n\n\t\tthis.enabled = true;\n\t\tthis.needsSwap = false;\n\n\t\tthis._oldClearColor = new Color();\n\t\tthis.oldClearAlpha = 1;\n\n\t\tthis.fsQuad = new FullScreenQuad( null );\n\n\t\tthis.tempPulseColor1 = new Color();\n\t\tthis.tempPulseColor2 = new Color();\n\t\tthis.textureMatrix = new Matrix4();\n\n\t\tfunction replaceDepthToViewZ( string, camera ) {\n\n\t\t\tconst type = camera.isPerspectiveCamera ? 'perspective' : 'orthographic';\n\n\t\t\treturn string.replace( /DEPTH_TO_VIEW_Z/g, type + 'DepthToViewZ' );\n\n\t\t}\n\n\t}\n\n\tdispose() {\n\n\t\tthis.renderTargetMaskBuffer.dispose();\n\t\tthis.renderTargetDepthBuffer.dispose();\n\t\tthis.renderTargetMaskDownSampleBuffer.dispose();\n\t\tthis.renderTargetBlurBuffer1.dispose();\n\t\tthis.renderTargetBlurBuffer2.dispose();\n\t\tthis.renderTargetEdgeBuffer1.dispose();\n\t\tthis.renderTargetEdgeBuffer2.dispose();\n\n\t}\n\n\tsetSize( width, height ) {\n\n\t\tthis.renderTargetMaskBuffer.setSize( width, height );\n\t\tthis.renderTargetDepthBuffer.setSize( width, height );\n\n\t\tlet resx = Math.round( width / this.downSampleRatio );\n\t\tlet resy = Math.round( height / this.downSampleRatio );\n\t\tthis.renderTargetMaskDownSampleBuffer.setSize( resx, resy );\n\t\tthis.renderTargetBlurBuffer1.setSize( resx, resy );\n\t\tthis.renderTargetEdgeBuffer1.setSize( resx, resy );\n\t\tthis.separableBlurMaterial1.uniforms[ 'texSize' ].value.set( resx, resy );\n\n\t\tresx = Math.round( resx / 2 );\n\t\tresy = Math.round( resy / 2 );\n\n\t\tthis.renderTargetBlurBuffer2.setSize( resx, resy );\n\t\tthis.renderTargetEdgeBuffer2.setSize( resx, resy );\n\n\t\tthis.separableBlurMaterial2.uniforms[ 'texSize' ].value.set( resx, resy );\n\n\t}\n\n\tchangeVisibilityOfSelectedObjects( bVisible ) {\n\n\t\tconst cache = this._visibilityCache;\n\n\t\tfunction gatherSelectedMeshesCallBack( object ) {\n\n\t\t\tif ( object.isMesh ) {\n\n\t\t\t\tif ( bVisible === true ) {\n\n\t\t\t\t\tobject.visible = cache.get( object );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tcache.set( object, object.visible );\n\t\t\t\t\tobject.visible = bVisible;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfor ( let i = 0; i < this.selectedObjects.length; i ++ ) {\n\n\t\t\tconst selectedObject = this.selectedObjects[ i ];\n\t\t\tselectedObject.traverse( gatherSelectedMeshesCallBack );\n\n\t\t}\n\n\t}\n\n\tchangeVisibilityOfNonSelectedObjects( bVisible ) {\n\n\t\tconst cache = this._visibilityCache;\n\t\tconst selectedMeshes = [];\n\n\t\tfunction gatherSelectedMeshesCallBack( object ) {\n\n\t\t\tif ( object.isMesh ) selectedMeshes.push( object );\n\n\t\t}\n\n\t\tfor ( let i = 0; i < this.selectedObjects.length; i ++ ) {\n\n\t\t\tconst selectedObject = this.selectedObjects[ i ];\n\t\t\tselectedObject.traverse( gatherSelectedMeshesCallBack );\n\n\t\t}\n\n\t\tfunction VisibilityChangeCallBack( object ) {\n\n\t\t\tif ( object.isMesh || object.isSprite ) {\n\n\t\t\t\t// only meshes and sprites are supported by OutlinePass\n\n\t\t\t\tlet bFound = false;\n\n\t\t\t\tfor ( let i = 0; i < selectedMeshes.length; i ++ ) {\n\n\t\t\t\t\tconst selectedObjectId = selectedMeshes[ i ].id;\n\n\t\t\t\t\tif ( selectedObjectId === object.id ) {\n\n\t\t\t\t\t\tbFound = true;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( bFound === false ) {\n\n\t\t\t\t\tconst visibility = object.visible;\n\n\t\t\t\t\tif ( bVisible === false || cache.get( object ) === true ) {\n\n\t\t\t\t\t\tobject.visible = bVisible;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tcache.set( object, visibility );\n\n\t\t\t\t}\n\n\t\t\t} else if ( object.isPoints || object.isLine ) {\n\n\t\t\t\t// the visibilty of points and lines is always set to false in order to\n\t\t\t\t// not affect the outline computation\n\n\t\t\t\tif ( bVisible === true ) {\n\n\t\t\t\t\tobject.visible = cache.get( object ); // restore\n\n\t\t\t\t} else {\n\n\t\t\t\t\tcache.set( object, object.visible );\n\t\t\t\t\tobject.visible = bVisible;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.renderScene.traverse( VisibilityChangeCallBack );\n\n\t}\n\n\tupdateTextureMatrix() {\n\n\t\tthis.textureMatrix.set( 0.5, 0.0, 0.0, 0.5,\n\t\t\t0.0, 0.5, 0.0, 0.5,\n\t\t\t0.0, 0.0, 0.5, 0.5,\n\t\t\t0.0, 0.0, 0.0, 1.0 );\n\t\tthis.textureMatrix.multiply( this.renderCamera.projectionMatrix );\n\t\tthis.textureMatrix.multiply( this.renderCamera.matrixWorldInverse );\n\n\t}\n\n\trender( renderer, writeBuffer, readBuffer, deltaTime, maskActive ) {\n\n\t\tif ( this.selectedObjects.length > 0 ) {\n\n\t\t\trenderer.getClearColor( this._oldClearColor );\n\t\t\tthis.oldClearAlpha = renderer.getClearAlpha();\n\t\t\tconst oldAutoClear = renderer.autoClear;\n\n\t\t\trenderer.autoClear = false;\n\n\t\t\tif ( maskActive ) renderer.state.buffers.stencil.setTest( false );\n\n\t\t\trenderer.setClearColor( 0xffffff, 1 );\n\n\t\t\t// Make selected objects invisible\n\t\t\tthis.changeVisibilityOfSelectedObjects( false );\n\n\t\t\tconst currentBackground = this.renderScene.background;\n\t\t\tthis.renderScene.background = null;\n\n\t\t\t// 1. Draw Non Selected objects in the depth buffer\n\t\t\tthis.renderScene.overrideMaterial = this.depthMaterial;\n\t\t\trenderer.setRenderTarget( this.renderTargetDepthBuffer );\n\t\t\trenderer.clear();\n\t\t\trenderer.render( this.renderScene, this.renderCamera );\n\n\t\t\t// Make selected objects visible\n\t\t\tthis.changeVisibilityOfSelectedObjects( true );\n\t\t\tthis._visibilityCache.clear();\n\n\t\t\t// Update Texture Matrix for Depth compare\n\t\t\tthis.updateTextureMatrix();\n\n\t\t\t// Make non selected objects invisible, and draw only the selected objects, by comparing the depth buffer of non selected objects\n\t\t\tthis.changeVisibilityOfNonSelectedObjects( false );\n\t\t\tthis.renderScene.overrideMaterial = this.prepareMaskMaterial;\n\t\t\tthis.prepareMaskMaterial.uniforms[ 'cameraNearFar' ].value.set( this.renderCamera.near, this.renderCamera.far );\n\t\t\tthis.prepareMaskMaterial.uniforms[ 'depthTexture' ].value = this.renderTargetDepthBuffer.texture;\n\t\t\tthis.prepareMaskMaterial.uniforms[ 'textureMatrix' ].value = this.textureMatrix;\n\t\t\trenderer.setRenderTarget( this.renderTargetMaskBuffer );\n\t\t\trenderer.clear();\n\t\t\trenderer.render( this.renderScene, this.renderCamera );\n\t\t\tthis.renderScene.overrideMaterial = null;\n\t\t\tthis.changeVisibilityOfNonSelectedObjects( true );\n\t\t\tthis._visibilityCache.clear();\n\n\t\t\tthis.renderScene.background = currentBackground;\n\n\t\t\t// 2. Downsample to Half resolution\n\t\t\tthis.fsQuad.material = this.materialCopy;\n\t\t\tthis.copyUniforms[ 'tDiffuse' ].value = this.renderTargetMaskBuffer.texture;\n\t\t\trenderer.setRenderTarget( this.renderTargetMaskDownSampleBuffer );\n\t\t\trenderer.clear();\n\t\t\tthis.fsQuad.render( renderer );\n\n\t\t\tthis.tempPulseColor1.copy( this.visibleEdgeColor );\n\t\t\tthis.tempPulseColor2.copy( this.hiddenEdgeColor );\n\n\t\t\tif ( this.pulsePeriod > 0 ) {\n\n\t\t\t\tconst scalar = ( 1 + 0.25 ) / 2 + Math.cos( performance.now() * 0.01 / this.pulsePeriod ) * ( 1.0 - 0.25 ) / 2;\n\t\t\t\tthis.tempPulseColor1.multiplyScalar( scalar );\n\t\t\t\tthis.tempPulseColor2.multiplyScalar( scalar );\n\n\t\t\t}\n\n\t\t\t// 3. Apply Edge Detection Pass\n\t\t\tthis.fsQuad.material = this.edgeDetectionMaterial;\n\t\t\tthis.edgeDetectionMaterial.uniforms[ 'maskTexture' ].value = this.renderTargetMaskDownSampleBuffer.texture;\n\t\t\tthis.edgeDetectionMaterial.uniforms[ 'texSize' ].value.set( this.renderTargetMaskDownSampleBuffer.width, this.renderTargetMaskDownSampleBuffer.height );\n\t\t\tthis.edgeDetectionMaterial.uniforms[ 'visibleEdgeColor' ].value = this.tempPulseColor1;\n\t\t\tthis.edgeDetectionMaterial.uniforms[ 'hiddenEdgeColor' ].value = this.tempPulseColor2;\n\t\t\trenderer.setRenderTarget( this.renderTargetEdgeBuffer1 );\n\t\t\trenderer.clear();\n\t\t\tthis.fsQuad.render( renderer );\n\n\t\t\t// 4. Apply Blur on Half res\n\t\t\tthis.fsQuad.material = this.separableBlurMaterial1;\n\t\t\tthis.separableBlurMaterial1.uniforms[ 'colorTexture' ].value = this.renderTargetEdgeBuffer1.texture;\n\t\t\tthis.separableBlurMaterial1.uniforms[ 'direction' ].value = OutlinePass.BlurDirectionX;\n\t\t\tthis.separableBlurMaterial1.uniforms[ 'kernelRadius' ].value = this.edgeThickness;\n\t\t\trenderer.setRenderTarget( this.renderTargetBlurBuffer1 );\n\t\t\trenderer.clear();\n\t\t\tthis.fsQuad.render( renderer );\n\t\t\tthis.separableBlurMaterial1.uniforms[ 'colorTexture' ].value = this.renderTargetBlurBuffer1.texture;\n\t\t\tthis.separableBlurMaterial1.uniforms[ 'direction' ].value = OutlinePass.BlurDirectionY;\n\t\t\trenderer.setRenderTarget( this.renderTargetEdgeBuffer1 );\n\t\t\trenderer.clear();\n\t\t\tthis.fsQuad.render( renderer );\n\n\t\t\t// Apply Blur on quarter res\n\t\t\tthis.fsQuad.material = this.separableBlurMaterial2;\n\t\t\tthis.separableBlurMaterial2.uniforms[ 'colorTexture' ].value = this.renderTargetEdgeBuffer1.texture;\n\t\t\tthis.separableBlurMaterial2.uniforms[ 'direction' ].value = OutlinePass.BlurDirectionX;\n\t\t\trenderer.setRenderTarget( this.renderTargetBlurBuffer2 );\n\t\t\trenderer.clear();\n\t\t\tthis.fsQuad.render( renderer );\n\t\t\tthis.separableBlurMaterial2.uniforms[ 'colorTexture' ].value = this.renderTargetBlurBuffer2.texture;\n\t\t\tthis.separableBlurMaterial2.uniforms[ 'direction' ].value = OutlinePass.BlurDirectionY;\n\t\t\trenderer.setRenderTarget( this.renderTargetEdgeBuffer2 );\n\t\t\trenderer.clear();\n\t\t\tthis.fsQuad.render( renderer );\n\n\t\t\t// Blend it additively over the input texture\n\t\t\tthis.fsQuad.material = this.overlayMaterial;\n\t\t\tthis.overlayMaterial.uniforms[ 'maskTexture' ].value = this.renderTargetMaskBuffer.texture;\n\t\t\tthis.overlayMaterial.uniforms[ 'edgeTexture1' ].value = this.renderTargetEdgeBuffer1.texture;\n\t\t\tthis.overlayMaterial.uniforms[ 'edgeTexture2' ].value = this.renderTargetEdgeBuffer2.texture;\n\t\t\tthis.overlayMaterial.uniforms[ 'patternTexture' ].value = this.patternTexture;\n\t\t\tthis.overlayMaterial.uniforms[ 'edgeStrength' ].value = this.edgeStrength;\n\t\t\tthis.overlayMaterial.uniforms[ 'edgeGlow' ].value = this.edgeGlow;\n\t\t\tthis.overlayMaterial.uniforms[ 'usePatternTexture' ].value = this.usePatternTexture;\n\n\n\t\t\tif ( maskActive ) renderer.state.buffers.stencil.setTest( true );\n\n\t\t\trenderer.setRenderTarget( readBuffer );\n\t\t\tthis.fsQuad.render( renderer );\n\n\t\t\trenderer.setClearColor( this._oldClearColor, this.oldClearAlpha );\n\t\t\trenderer.autoClear = oldAutoClear;\n\n\t\t}\n\n\t\tif ( this.renderToScreen ) {\n\n\t\t\tthis.fsQuad.material = this.materialCopy;\n\t\t\tthis.copyUniforms[ 'tDiffuse' ].value = readBuffer.texture;\n\t\t\trenderer.setRenderTarget( null );\n\t\t\tthis.fsQuad.render( renderer );\n\n\t\t}\n\n\t}\n\n\tgetPrepareMaskMaterial() {\n\n\t\treturn new ShaderMaterial( {\n\n\t\t\tuniforms: {\n\t\t\t\t'depthTexture': { value: null },\n\t\t\t\t'cameraNearFar': { value: new Vector2( 0.5, 0.5 ) },\n\t\t\t\t'textureMatrix': { value: null }\n\t\t\t},\n\n\t\t\tvertexShader:\n\t\t\t\t`#include <morphtarget_pars_vertex>\n\t\t\t\t#include <skinning_pars_vertex>\n\n\t\t\t\tvarying vec4 projTexCoord;\n\t\t\t\tvarying vec4 vPosition;\n\t\t\t\tuniform mat4 textureMatrix;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\t#include <skinbase_vertex>\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <morphtarget_vertex>\n\t\t\t\t\t#include <skinning_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t\tvPosition = mvPosition;\n\t\t\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\n\t\t\t\t\tprojTexCoord = textureMatrix * worldPosition;\n\n\t\t\t\t}`,\n\n\t\t\tfragmentShader:\n\t\t\t\t`#include <packing>\n\t\t\t\tvarying vec4 vPosition;\n\t\t\t\tvarying vec4 projTexCoord;\n\t\t\t\tuniform sampler2D depthTexture;\n\t\t\t\tuniform vec2 cameraNearFar;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tfloat depth = unpackRGBAToDepth(texture2DProj( depthTexture, projTexCoord ));\n\t\t\t\t\tfloat viewZ = - DEPTH_TO_VIEW_Z( depth, cameraNearFar.x, cameraNearFar.y );\n\t\t\t\t\tfloat depthTest = (-vPosition.z > viewZ) ? 1.0 : 0.0;\n\t\t\t\t\tgl_FragColor = vec4(0.0, depthTest, 1.0, 1.0);\n\n\t\t\t\t}`\n\n\t\t} );\n\n\t}\n\n\tgetEdgeDetectionMaterial() {\n\n\t\treturn new ShaderMaterial( {\n\n\t\t\tuniforms: {\n\t\t\t\t'maskTexture': { value: null },\n\t\t\t\t'texSize': { value: new Vector2( 0.5, 0.5 ) },\n\t\t\t\t'visibleEdgeColor': { value: new Vector3( 1.0, 1.0, 1.0 ) },\n\t\t\t\t'hiddenEdgeColor': { value: new Vector3( 1.0, 1.0, 1.0 ) },\n\t\t\t},\n\n\t\t\tvertexShader:\n\t\t\t\t`varying vec2 vUv;\n\n\t\t\t\tvoid main() {\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t}`,\n\n\t\t\tfragmentShader:\n\t\t\t\t`varying vec2 vUv;\n\n\t\t\t\tuniform sampler2D maskTexture;\n\t\t\t\tuniform vec2 texSize;\n\t\t\t\tuniform vec3 visibleEdgeColor;\n\t\t\t\tuniform vec3 hiddenEdgeColor;\n\n\t\t\t\tvoid main() {\n\t\t\t\t\tvec2 invSize = 1.0 / texSize;\n\t\t\t\t\tvec4 uvOffset = vec4(1.0, 0.0, 0.0, 1.0) * vec4(invSize, invSize);\n\t\t\t\t\tvec4 c1 = texture2D( maskTexture, vUv + uvOffset.xy);\n\t\t\t\t\tvec4 c2 = texture2D( maskTexture, vUv - uvOffset.xy);\n\t\t\t\t\tvec4 c3 = texture2D( maskTexture, vUv + uvOffset.yw);\n\t\t\t\t\tvec4 c4 = texture2D( maskTexture, vUv - uvOffset.yw);\n\t\t\t\t\tfloat diff1 = (c1.r - c2.r)*0.5;\n\t\t\t\t\tfloat diff2 = (c3.r - c4.r)*0.5;\n\t\t\t\t\tfloat d = length( vec2(diff1, diff2) );\n\t\t\t\t\tfloat a1 = min(c1.g, c2.g);\n\t\t\t\t\tfloat a2 = min(c3.g, c4.g);\n\t\t\t\t\tfloat visibilityFactor = min(a1, a2);\n\t\t\t\t\tvec3 edgeColor = 1.0 - visibilityFactor > 0.001 ? visibleEdgeColor : hiddenEdgeColor;\n\t\t\t\t\tgl_FragColor = vec4(edgeColor, 1.0) * vec4(d);\n\t\t\t\t}`\n\t\t} );\n\n\t}\n\n\tgetSeperableBlurMaterial( maxRadius ) {\n\n\t\treturn new ShaderMaterial( {\n\n\t\t\tdefines: {\n\t\t\t\t'MAX_RADIUS': maxRadius,\n\t\t\t},\n\n\t\t\tuniforms: {\n\t\t\t\t'colorTexture': { value: null },\n\t\t\t\t'texSize': { value: new Vector2( 0.5, 0.5 ) },\n\t\t\t\t'direction': { value: new Vector2( 0.5, 0.5 ) },\n\t\t\t\t'kernelRadius': { value: 1.0 }\n\t\t\t},\n\n\t\t\tvertexShader:\n\t\t\t\t`varying vec2 vUv;\n\n\t\t\t\tvoid main() {\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t}`,\n\n\t\t\tfragmentShader:\n\t\t\t\t`#include <common>\n\t\t\t\tvarying vec2 vUv;\n\t\t\t\tuniform sampler2D colorTexture;\n\t\t\t\tuniform vec2 texSize;\n\t\t\t\tuniform vec2 direction;\n\t\t\t\tuniform float kernelRadius;\n\n\t\t\t\tfloat gaussianPdf(in float x, in float sigma) {\n\t\t\t\t\treturn 0.39894 * exp( -0.5 * x * x/( sigma * sigma))/sigma;\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\t\t\t\t\tvec2 invSize = 1.0 / texSize;\n\t\t\t\t\tfloat weightSum = gaussianPdf(0.0, kernelRadius);\n\t\t\t\t\tvec4 diffuseSum = texture2D( colorTexture, vUv) * weightSum;\n\t\t\t\t\tvec2 delta = direction * invSize * kernelRadius/float(MAX_RADIUS);\n\t\t\t\t\tvec2 uvOffset = delta;\n\t\t\t\t\tfor( int i = 1; i <= MAX_RADIUS; i ++ ) {\n\t\t\t\t\t\tfloat w = gaussianPdf(uvOffset.x, kernelRadius);\n\t\t\t\t\t\tvec4 sample1 = texture2D( colorTexture, vUv + uvOffset);\n\t\t\t\t\t\tvec4 sample2 = texture2D( colorTexture, vUv - uvOffset);\n\t\t\t\t\t\tdiffuseSum += ((sample1 + sample2) * w);\n\t\t\t\t\t\tweightSum += (2.0 * w);\n\t\t\t\t\t\tuvOffset += delta;\n\t\t\t\t\t}\n\t\t\t\t\tgl_FragColor = diffuseSum/weightSum;\n\t\t\t\t}`\n\t\t} );\n\n\t}\n\n\tgetOverlayMaterial() {\n\n\t\treturn new ShaderMaterial( {\n\n\t\t\tuniforms: {\n\t\t\t\t'maskTexture': { value: null },\n\t\t\t\t'edgeTexture1': { value: null },\n\t\t\t\t'edgeTexture2': { value: null },\n\t\t\t\t'patternTexture': { value: null },\n\t\t\t\t'edgeStrength': { value: 1.0 },\n\t\t\t\t'edgeGlow': { value: 1.0 },\n\t\t\t\t'usePatternTexture': { value: 0.0 }\n\t\t\t},\n\n\t\t\tvertexShader:\n\t\t\t\t`varying vec2 vUv;\n\n\t\t\t\tvoid main() {\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t}`,\n\n\t\t\tfragmentShader:\n\t\t\t\t`varying vec2 vUv;\n\n\t\t\t\tuniform sampler2D maskTexture;\n\t\t\t\tuniform sampler2D edgeTexture1;\n\t\t\t\tuniform sampler2D edgeTexture2;\n\t\t\t\tuniform sampler2D patternTexture;\n\t\t\t\tuniform float edgeStrength;\n\t\t\t\tuniform float edgeGlow;\n\t\t\t\tuniform bool usePatternTexture;\n\n\t\t\t\tvoid main() {\n\t\t\t\t\tvec4 edgeValue1 = texture2D(edgeTexture1, vUv);\n\t\t\t\t\tvec4 edgeValue2 = texture2D(edgeTexture2, vUv);\n\t\t\t\t\tvec4 maskColor = texture2D(maskTexture, vUv);\n\t\t\t\t\tvec4 patternColor = texture2D(patternTexture, 6.0 * vUv);\n\t\t\t\t\tfloat visibilityFactor = 1.0 - maskColor.g > 0.0 ? 1.0 : 0.5;\n\t\t\t\t\tvec4 edgeValue = edgeValue1 + edgeValue2 * edgeGlow;\n\t\t\t\t\tvec4 finalColor = edgeStrength * maskColor.r * edgeValue;\n\t\t\t\t\tif(usePatternTexture)\n\t\t\t\t\t\tfinalColor += + visibilityFactor * (1.0 - maskColor.r) * (1.0 - patternColor.r);\n\t\t\t\t\tgl_FragColor = finalColor;\n\t\t\t\t}`,\n\t\t\tblending: AdditiveBlending,\n\t\t\tdepthTest: false,\n\t\t\tdepthWrite: false,\n\t\t\ttransparent: true\n\t\t} );\n\n\t}\n\n}\n\nOutlinePass.BlurDirectionX = new Vector2( 1.0, 0.0 );\nOutlinePass.BlurDirectionY = new Vector2( 0.0, 1.0 );\n\nexport { OutlinePass };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}